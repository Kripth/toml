// Written in the D programming language.

/*
 *	Boost Software License - Version 1.0 - August 17th, 2003
 *	
 *	Permission is hereby granted, free of charge, to any person or organization
 *	obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 *
 */
module toml;

import std.algorithm : canFind, min;
import std.array : Appender;
import std.ascii : newline;
import std.conv : to;
import std.datetime : SysTime, DateTime, Date, TimeOfDay, TimeZone;
import std.exception : enforce;
import std.json : JSON_TYPE, JSONValue;
import std.string : join, strip, replace, indexOf;
import std.traits : isNumeric, isIntegral, isFloatingPoint, isArray, isAssociativeArray, KeyType;
import std.utf : encode, UseReplacementDchar;

debug import std.stdio : writeln;

enum TOML_TYPE : byte {

	NULL, // used for empty object
	BOOL,
	STRING,
	INTEGER,
	FLOAT,
	OFFSET_DATETIME,
	LOCAL_DATETIME,
	LOCAL_DATE,
	LOCAL_TIME,
	ARRAY,
	TABLE

}

struct TOMLDocument {

	private TOMLValue[string] values;

	public this(TOMLValue[string] values) {
		this.values = values;
	}

	/*public @property TOMLValue object() {
		return TOMLValue(this.values);
	}*/

	public TOMLValue* opBinaryRight(string op : "in")(string key) {
		return key in this.values;
	}

	public TOMLValue opIndex(string key) {
		return this.values[key];
	}

	public string toString() {
		Appender!string appender;
		foreach(key, value; this.values) {
			appender.put(key); //TODO quote if necessary
			appender.put("=");
			stringify(appender, value);
			appender.put(newline);
		}
		return appender.data;
	}

}

struct TOMLValue {

	private union Store {
		bool boolean;
		string str;
		long integer;
		double floating;
		SysTime offsetDatetime;
		DateTime localDatetime;
		Date localDate;
		TimeOfDay localTime;
		TOMLValue[] array;
		TOMLValue[string] table;
	}
	private Store store;
	private TOML_TYPE tag_type;

	public pure nothrow @property @safe @nogc TOML_TYPE type() {
		return this.tag_type;
	}

	public this(T)(T value) {
		static if(is(T == TOML_TYPE)) {
			this.tag_type = value;
		} else {
			this.assign(value);
		}
	}

	public @property bool boolean() {
		enforce!TOMLException(this.type == TOML_TYPE.BOOL, "TOMLValue is not a boolean");
		return this.store.boolean;
	}

	public @property string str() {
		enforce!TOMLException(this.type == TOML_TYPE.STRING, "TOMLValue is not a string");
		return this.store.str;
	}

	public @property long integer() {
		enforce!TOMLException(this.type == TOML_TYPE.INTEGER, "TOMLValue is not an integer");
		return this.store.integer;
	}

	public @property double floating() {
		enforce!TOMLException(this.type == TOML_TYPE.FLOAT, "TOMLValue is not a float");
		return this.store.floating;
	}

	public @property ref SysTime offsetDatetime() {
		enforce!TOMLException(this.type == TOML_TYPE.OFFSET_DATETIME, "TOMLValue is not an offset datetime");
		return this.store.offsetDatetime;
	}

	public @property ref DateTime localDatetime() {
		enforce!TOMLException(this.type == TOML_TYPE.LOCAL_DATETIME, "TOMLValue is not a local datetime");
		return this.store.localDatetime;
	}

	public @property ref Date localDate() {
		enforce!TOMLException(this.type == TOML_TYPE.LOCAL_DATE, "TOMLValue is not a local date");
		return this.store.localDate;
	}

	public @property ref TimeOfDay localTime() {
		enforce!TOMLException(this.type == TOML_TYPE.LOCAL_TIME, "TOMLValue is not a local time");
		return this.store.localTime;
	}

	public @property ref TOMLValue[] array() {
		enforce!TOMLException(this.type == TOML_TYPE.ARRAY, "TOMLValue is not an array");
		return this.store.array;
	}

	public @property ref TOMLValue[string] table() {
		enforce!TOMLException(this.type == TOML_TYPE.TABLE, "TOMLValue is not a table");
		return this.store.table;
	}

	public TOMLValue* opBinaryRight(string op : "in")(string key) {
		return key in this.table;
	}

	public TOMLValue opIndex(string key) {
		return this.table[key];
	}

	public void opAssign(T)(T value) {
		this.assign(value);
	}

	private void assign(T)(T value) {
		static if(is(T == TOMLValue)) {
			this.store = value.store;
			this.tag_type = value.tag_type;
		} else static if(is(T == bool)) {
			this.store.boolean = value;
			this.tag_type = TOML_TYPE.BOOL;
		} else static if(is(T : string)) {
			this.store.str = value;
			this.tag_type = TOML_TYPE.STRING;
		} else static if(isIntegral!T) {
			this.store.integer = value;
			this.tag_type = TOML_TYPE.INTEGER;
		} else static if(isFloatingPoint!T) {
			this.store.floating = cast(double)value;
			this.tag_type = TOML_TYPE.FLOAT;
		} else static if(is(T == SysTime)) {
			this.store.offsetDatetime = value;
			this.tag_type = TOML_TYPE.OFFSET_DATETIME;
		} else static if(is(T == DateTime)) {
			this.store.localDatetime = value;
			this.tag_type = TOML_TYPE.LOCAL_DATETIME;
		} else static if(is(T == Date)) {
			this.store.localDate = value;
			this.tag_type = TOML_TYPE.LOCAL_DATE;
		} else static if(is(T == TimeOfDay)) {
			this.store.localTime = value;
			this.tag_type = TOML_TYPE.LOCAL_TIME;
		} else static if(isArray!T) {
			static if(is(T == TOMLValue[])) {
				if(value.length) {
					// verify that every element has the same type
					TOML_TYPE cmp = value[0].type;
					foreach(element ; value[1..$]) {
						enforce!TOMLException(element.type == cmp, "Array's values must be of the same type");
					}
				}
				alias data = value;
			} else {
				TOMLValue[] data;
				foreach(element ; value) {
					data ~= TOMLValue(element);
				}
			}
			this.store.array = data;
			this.tag_type = TOML_TYPE.ARRAY;
		} else static if(isAssociativeArray!T && is(KeyType!T : string)) {
			static if(is(T == TOMLValue[string])) {
				alias data = value;
			} else {
				TOMLValue[string] data;
				foreach(key, v; value) {
					data[key] = v;
				}
			}
			this.store.table = data;
			this.tag_type = TOML_TYPE.TABLE;
		} else {
			static assert(0);
		}
	}

	public bool opEquals(T)(T value) {
		static if(is(T == TOMLValue)) {
			if(this.type != value.type) return false;
			final switch(this.type) with(TOML_TYPE) {
				case NULL: return false;
				case BOOL: return this.store.boolean == value.store.boolean;
				case STRING: return this.store.str == value.store.str;
				case INTEGER: return this.store.integer == value.store.integer;
				case FLOAT: return this.store.floating == value.store.floating;
				case OFFSET_DATETIME: return this.store.offsetDatetime == value.store.offsetDatetime;
				case LOCAL_DATETIME: return this.store.localDatetime == value.store.localDatetime;
				case LOCAL_DATE: return this.store.localDate == value.store.localDate;
				case LOCAL_TIME: return this.store.localTime == value.store.localTime;
				case ARRAY: return this.store.array == value.store.array;
				case TABLE: return this.store.table == value.store.table;
			}
		} else static if(is(T : string)) {
			return this.type == TOML_TYPE.STRING && this.store.str == value;
		} else static if(isNumeric!T || is(T == bool)) {
			if(this.type == TOML_TYPE.BOOL) return this.store.boolean == value;
			else if(this.type == TOML_TYPE.INTEGER) return this.store.integer == value;
			else if(this.type == TOML_TYPE.FLOAT) return this.store.floating == value;
			else return false;
		} else static if(is(T == SysTime)) {
			return this.type == TOML_TYPE.OFFSET_DATETIME && this.store.offsetDatetime == value;
		} else static if(is(T == DateTime)) {
			return this.type == TOML_TYPE.LOCAL_DATETIME && this.store.localDatetime == value;
		} else static if(is(T == Date)) {
			return this.type == TOML_TYPE.LOCAL_DATE && this.store.localDate == value;
		} else static if(is(T == TimeOfDay)) {
			return this.type == TOML_TYPE.LOCAL_TIME && this.store.localTime == value;
		} else static if(isArray!T) {
			if(this.type != TOML_TYPE.ARRAY || this.store.array.length != value.length) return false;
			foreach(i, element; this.store.array) {
				if(element != value[i]) return false;
			}
			return true;
		} else static if(isAssociativeArray!T && is(KeyType!T : string)) {
			if(this.type != TOML_TYPE.TABLE || this.store.table.length != value.length) return false;
			foreach(key, v; this.store.table) {
				auto cmp = key in value;
				if(cmp is null || v != *cmp) return false;
			}
			return true;
		} else {
			return false;
		}
	}

}

private void stringify(ref Appender!string appender, TOMLValue value) {
	final switch(value.type) with(TOML_TYPE) {
		case NULL: 
			//TODO throw exception
			break;
		case BOOL:
			appender.put(value.boolean.to!string);
			break;
		case STRING:
			appender.put(value.str); //TODO quote
			break;
		case INTEGER:
			appender.put(value.integer.to!string);
			break;
		case FLOAT:
			//TODO check nan and infinity
			appender.put(value.floating.to!string);
			appender.put("f");
			break;
		case OFFSET_DATETIME:
			appender.put(value.offsetDatetime.toISOExtString());
			break;
		case LOCAL_DATETIME:
			appender.put(value.localDatetime.toISOExtString());
			break;
		case LOCAL_DATE:
			appender.put(value.localDate.toISOExtString());
			break;
		case LOCAL_TIME:
			appender.put(value.localTime.toISOExtString());
			break;
		case ARRAY:

			break;
		case TABLE:

			break;
	}
}

private TOMLDocument parseTOMLImpl(string data, size_t index) {

	TOMLValue[string] _ret;
	auto current = &_ret;

	void set(string key, TOMLValue value) {
		enforce!TOMLException(key !in *current, "Key '" ~ key ~ "' is already defined");
		(*current)[key] = value;
	}

	/**
	 * Removes whitespace characters and comments.
	 * Return: whether there's still data to read
	 */
	bool clear(bool clear_newline=true)() {
		static if(clear_newline) {
			enum chars = " \b\t\n\f\r";
		} else {
			enum chars = " \b\t\f\r";
		}
		if(index < data.length) {
			if(chars.canFind(data[index])) {
				index++;
				return clear!clear_newline();
			} else if(data[index] == '#') {
				// skip until end of line
				while(++index < data.length && data[index] != '\n') {}
				static if(clear_newline) {
					index++; // point at the next character
					return clear();
				} else {
					return true;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}

	/**
	 * Indicates whether the given character is valid in an unquoted key.
	 */
	bool isValidKeyChar(immutable char c) {
		return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '-' || c == '_';
	}

	string readQuotedString(bool multiline)() {
		Appender!string ret;
		bool backslash = false;
		while(index < data.length) {
			static if(!multiline) {
				if(data[index] == '\n') {
					throw new TOMLException("Unterminated quoted string");
				}
			}
			if(backslash) {
				void readUnicode(size_t size)() {
					enforce!TOMLException(index + size < data.length, "Invalid UTF-8 sequence");
					char[4] buffer;
					immutable len = encode!(UseReplacementDchar.yes)(buffer, cast(dchar)to!ulong(data[index+1..index+1+size], 16));
					ret.put(buffer[0..len].idup);
					index += size;
				}
				switch(data[index]) {
					case '"': ret.put('"'); break;
					case '\\': ret.put('\\'); break;
					case 'b': ret.put('\b'); break;
					case 't': ret.put('\t'); break;
					case 'n': ret.put('\n'); break;
					case 'f': ret.put('\f'); break;
					case 'r': ret.put('\r'); break;
					case 'u': readUnicode!4(); break;
					case 'U': readUnicode!8(); break;
					default:
						static if(multiline) {
							index++;
							if(clear()) {
								// remove whitespace characters until next valid character
								index--;
								break;
							}
						}
						throw new TOMLException("Invalid escape sequence: '\\" ~ data[index], "'");
				}
				backslash = false;
			} else {
				if(data[index] == '\\') {
					backslash = true;
				} else if(data[index] == '"') {
					// string closed
					index++;
					static if(multiline) {
						// control that the string is really closed
						if(index + 2 <= data.length && data[index..index+2] == "\"\"") {
							index += 2;
							return ret.data.stripFirstLine;
						} else {
							ret.put("\"");
							continue;
						}
					} else {
						return ret.data;
					}
				} else {
					static if(multiline) {
						mixin(doLineConversion);
					}
					ret.put(data[index]);
				}
			}
			index++;
		}
		throw new TOMLException("Expecting \" (double quote) but found EOF");
	}

	string readSimpleQuotedString(bool multiline)() {
		Appender!string ret;
		while(index < data.length) {
			static if(!multiline) {
				if(data[index] == '\n') {
					throw new TOMLException("Unterminated quoted string");
				}
			}
			if(data[index] == '\'') {
				// closed
				index++;
				static if(multiline) {
					// there must be 3 of them
					if(index + 2 <= data.length && data[index..index+2] == "''") {
						index += 2;
						return ret.data.stripFirstLine;
					} else {
						ret.put("'");
					}
				} else {
					return ret.data;
				}
			} else {
				static if(multiline) {
					mixin(doLineConversion);
				}
				ret.put(data[index++]);
			}
		}
		throw new TOMLException("Expecting ' (single quote) but found EOF");
	}

	TOMLValue readNumber() {
		immutable start = index;
		while(index < data.length && "0123456789_+-.eE:TZ".canFind(data[index])) index++;
		enforce!TOMLException(start != index, "Invalid number or date");
		string ret = replace(data[start..index], "_", "");
		if(ret.length >= 10 && ret[4] == '-' && ret[7] == '-') {
			// date or datetime
			if(ret.length >= 19 && ret[10] == 'T' && ret[13] == ':' && ret[16] == ':') {
				// datetime
				if(ret[19..$].canFind("-") || ret[$-1] == 'Z') {
					// has timezone
					return TOMLValue(SysTime.fromISOExtString(ret));
				} else {
					//return TOMLValue(DateTime(date, TimeOfDay.fromISOExtString(ret[11..19])));
					//TODO fractional part support
					return TOMLValue(DateTime.fromISOExtString(ret[0..19]));
				}
			} else {
				return TOMLValue(Date.fromISOExtString(ret[0..10]));
			}
		} else if(ret.length >= 8 && ret[2] == ':' && ret[5] == ':') {
			//TODO fractional support
			return TOMLValue(TimeOfDay.fromISOExtString(ret[0..8]));
		}
		ret = ret.replace("_", "");
		if(ret.canFind('.') || ret.canFind('e') || ret.canFind('E')) {
			return TOMLValue(to!double(ret));
		} else {
			return TOMLValue(to!long(ret));
		}
	}

	TOMLValue readValue() {
		switch(data[index++]) {
			case '"':
				if(index + 2 <= data.length && data[index..index+2] == "\"\"") {
					index += 2;
					return TOMLValue(readQuotedString!true());
				} else {
					return TOMLValue(readQuotedString!false());
				}
			case '\'':
				if(index + 2 <= data.length && data[index..index+2] == "''") {
					index += 2;
					return TOMLValue(readSimpleQuotedString!true());
				} else {
					return TOMLValue(readSimpleQuotedString!false());
				}
			case '[':
				clear();
				TOMLValue[] array;
				bool comma = true;
				while(data[index] != ']') {
					enforce!TOMLException(comma, "Elements of the array must be separated with a comma");
					array ~= readValue();
					clear!false(); // spaces allowed between elements and commas
					if(data[index] == ',') {
						index++;
						comma = true;
					} else {
						comma = false;
					}
					clear(); // spaces and newlines allowed between elements
				}
				index++;
				return TOMLValue(array);
			case '{':
				//TODO read object
				goto default;
			case 't':
				if(index + 3 <= data.length && data[index..index+3] == "rue") {
					index += 3;
					return TOMLValue(true);
				} else {
					goto default;
				}
			case 'f':
				if(index + 4 <= data.length && data[index..index+4] == "alse") {
					index += 4;
					return TOMLValue(false);
				} else {
					goto default;
				}
			case '+':
				return readNumber();
			case '-':
				index--;
				return readNumber();
			case '0': .. case '9':
				index--;
				return readNumber();
			default:
				throw new TOMLException("Unrecognized declaration");
		}
	}

	void readKeyValue(string key) {
		if(clear()) {
			assert(data[index++] == '='); //TODO better exception
			if(clear()) {
				set(key, readValue());
				// there must be nothing after the key/value declaration except comments and whitespaces
				if(clear!false() && data[index] != '\n') throw new TOMLException("Invalid characters after value declaration: " ~ data[index]);
			} else {
				//TODO throw exception (missing value)
			}
		} else {
			//TODO throw exception (missing value)
		}
	}
	
	string readKey() {
		enforce!TOMLException(index < data.length, "Key declaration expected but found EOF");
		if(data[index] == '"') {
			index++;
			return readQuotedString!false();
		} else if(data[index] == '\'') {
			index++;
			return readSimpleQuotedString!false();
		} else {
			Appender!string ret;
			while(index < data.length && isValidKeyChar(data[index])) {
				ret.put(data[index++]);
			}
			return ret.data;
		}
	}
	
	void next() {

		if(data[index] == '[') {
			current = &_ret; // reset base
			index++;
			while(true) {
				clear!false();
				immutable key = readKey();
				enforce!TOMLException(key.length, "Invalid key: " ~ key);
				auto exist = key in *current;
				if(exist) {
					current = &((*exist).table());
				} else {
					set(key, TOMLValue(TOML_TYPE.TABLE));
					current = &((*current)[key].table());
				}
				if(clear!false()) {
					if(data[index] == ']') {
						index++;
						break;
					} else {
						enforce!TOMLException(data[index++] == '.', "Expected '.'");
					}
				} else {
					throw new TOMLException("Expected ']' or '.' but found EOF");
				}
			}
		} else {
			immutable key = readKey();
			enforce!TOMLException(key.length, "Expecting key declaration but found " ~ data[index]);
			readKeyValue(key);
		}

	}

	while(clear()) {
		next();
	}

	return TOMLDocument(_ret);

}

private @property string stripFirstLine(string data) {
	size_t i = 0;
	while(i < data.length && data[i] != '\n') i++;
	if(data[0..i].strip.length == 0) return data[i+1..$];
	else return data;
}

private enum doLineConversion = q{
	version(Posix) {
		// convert windows' line ending to posix's
		if(data[index] == '\r' && index + 1 < data.length && data[index+1] == '\n') {
			index += 2;
			ret.put("\n");
			continue;
		}
	} else {
		// convert posix's line ending to windows'
		if(data[index] == '\n' && index != 0 && data[index-1] != '\r') {
			index++;
			ret.put("\r\n");
			continue;
		}
	}
};

/**
 * Parses a string into a TOML document.
 */
public TOMLDocument parseTOML(string data) {
	return parseTOMLImpl(data, 0);
}

///
unittest {

	void testError(void function() func) {
		try {
			func();
			assert(0);
		} catch(TOMLException) {}
	}

	TOMLDocument doc;

	// tests from the official documentation
	// https://github.com/toml-lang/toml/blob/master/README.md

	doc = parseTOML(`
		# This is a full-line comment
		key = "value"
	`);
	assert("key" in doc);
	assert(doc["key"].type == TOML_TYPE.STRING);
	assert(doc["key"] == "value");

	doc = parseTOML(`
		key = "value"
		bare_key = "value"
		bare-key = "value"
		1234 = "value"
		
		"127.0.0.1" = "value"
		"character encoding" = "value"
		"ʎǝʞ" = "value"
		'key2' = "value"
		'quoted "value"' = "value"
	`);
	assert(doc["key"] == "value");
	assert(doc["bare_key"] == "value");
	assert(doc["bare-key"] == "value");
	assert(doc["1234"] == "value");
	assert(doc["127.0.0.1"] == "value");
	assert(doc["character encoding"] == "value");
	assert(doc["ʎǝʞ"] == "value");
	assert(doc["key2"] == "value");
	assert(doc["quoted \"value\""] == "value");

	testError({ parseTOML(`= "no key name"`); });

	doc = parseTOML(`str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."`);
	assert(doc["str"] == "I'm a string. \"You can quote me\". Name\tJosé\nLocation\tSF.");

	doc = parseTOML(`str1 = """
Roses are red
Violets are blue"""`);
	version(Posix) {
		assert(doc["str1"] == "Roses are red\nViolets are blue");
	} else {
		assert(doc["str1"] == "Roses are red\r\nViolets are blue");
	}

	doc = parseTOML(`
		# The following strings are byte-for-byte equivalent:
		str1 = "The quick brown fox jumps over the lazy dog."
		
		str2 = """
The quick brown \


		  fox jumps over \
		    the lazy dog."""
		
		str3 = """\
			The quick brown \
			fox jumps over \
			the lazy dog.\
       """`);
	assert(doc["str1"] == "The quick brown fox jumps over the lazy dog.");
	assert(doc["str1"] == doc["str2"]);
	assert(doc["str1"] == doc["str3"]);

	doc = parseTOML(`
		# What you see is what you get.
		winpath  = 'C:\Users\nodejs\templates'
		winpath2 = '\\ServerX\admin$\system32\'
		quoted   = 'Tom "Dubs" Preston-Werner'
		regex    = '<\i\c*\s*>'
	`);
	assert(doc["winpath"] == `C:\Users\nodejs\templates`);
	assert(doc["winpath2"] == `\\ServerX\admin$\system32\`);
	assert(doc["quoted"] == `Tom "Dubs" Preston-Werner`);
	assert(doc["regex"] == `<\i\c*\s*>`);

	doc = parseTOML(`
		regex2 = '''I [dw]on't need \d{2} apples'''
		lines  = '''
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
'''`);
	assert(doc["regex2"] == `I [dw]on't need \d{2} apples`);
	assert(doc["lines"] == "The first newline is" ~ newline ~ "trimmed in raw strings." ~ newline ~ "   All other whitespace" ~ newline ~ "   is preserved." ~ newline);

	doc = parseTOML(`
		int1 = +99
		int2 = 42
		int3 = 0
		int4 = -17
	`);
	assert(doc["int1"] == 99);
	assert(doc["int2"] == 42);
	assert(doc["int3"] == 0);
	assert(doc["int4"] == -17);

	doc = parseTOML(`
		int5 = 1_000
		int6 = 5_349_221
		int7 = 1_2_3_4_5     # VALID but discouraged
	`);
	assert(doc["int5"] == 1_000);
	assert(doc["int6"] == 5_349_221);
	assert(doc["int7"] == 1_2_3_4_5);

	doc = parseTOML(`
		# fractional
		flt1 = +1.0
		flt2 = 3.1415
		flt3 = -0.01

		# exponent
		flt4 = 5e+22
		flt5 = 1e6
		flt6 = -2E-2

		# both
		flt7 = 6.626e-34
	`);
	assert(doc["flt1"].type == TOML_TYPE.FLOAT);
	assert(doc["flt1"] == 1);
	assert(doc["flt2"] == 3.1415);
	assert(doc["flt3"] == -.01);
	assert(doc["flt4"] == 5e+22);
	assert(doc["flt5"] == 1e6);
	assert(doc["flt6"] == -2E-2);
	assert(doc["flt7"] == 6.626e-34);

	doc = parseTOML(`flt8 = 9_224_617.445_991_228_313`);
	assert(doc["flt8"] == 9_224_617.445_991_228_313);

	doc = parseTOML(`
		bool1 = true
		bool2 = false
	`);
	assert(doc["bool1"] == true);
	assert(doc["bool2"] == false);

	doc = parseTOML(`
		odt1 = 1979-05-27T07:32:00Z
		odt2 = 1979-05-27T00:32:00-07:00
		odt3 = 1979-05-27T00:32:00.999999-07:00
	`);
	assert(doc["odt1"] == SysTime.fromISOExtString("1979-05-27T07:32:00Z"));
	assert(doc["odt2"] == SysTime.fromISOExtString("1979-05-27T00:32:00-07:00"));
	assert(doc["odt3"] == SysTime.fromISOExtString("1979-05-27T00:32:00.999999-07:00"));

	doc = parseTOML(`
		ldt1 = 1979-05-27T07:32:00
		ldt2 = 1979-05-27T00:32:00.999999
	`);
	assert(doc["ldt1"] == DateTime.fromISOExtString("1979-05-27T07:32:00"));
	assert(doc["ldt2"] == DateTime.fromISOExtString("1979-05-27T00:32:00")); //TODO fractional support

	doc = parseTOML(`
		ld1 = 1979-05-27
	`);
	assert(doc["ld1"] == Date.fromISOExtString("1979-05-27"));

	doc = parseTOML(`
		lt1 = 07:32:00
		lt2 = 00:32:00.999999
	`);
	assert(doc["lt1"] == TimeOfDay.fromISOExtString("07:32:00"));
	assert(doc["lt2"] == TimeOfDay.fromISOExtString("00:32:00")); //TODO fractional support

	doc = parseTOML(`
		arr1 = [ 1, 2, 3 ]
		arr2 = [ "red", "yellow", "green" ]
		arr3 = [ [ 1, 2 ], [3, 4, 5] ]
		arr4 = [ "all", 'strings', """are the same""", '''type''']
		arr5 = [ [ 1, 2 ], ["a", "b", "c"] ]
	`);
	assert(doc["arr1"] == [1, 2, 3]);
	assert(doc["arr2"] == ["red", "yellow", "green"]);
	assert(doc["arr3"] == [[1, 2], [3, 4, 5]]);
	assert(doc["arr4"] == ["all", "strings", "are the same", "type"]);
	assert(doc["arr5"] == [TOMLValue([1, 2]), TOMLValue(["a", "b", "c"])]);

	testError({ parseTOML(`arr6 = [ 1, 2.0 ]`); });

	doc = parseTOML(`
		arr7 = [
		  1, 2, 3
		]

		arr8 = [
		  1,
		  2, # this is ok
		]
	`);
	assert(doc["arr7"] == [1, 2, 3]);
	assert(doc["arr8"] == [1, 2]);

	doc = parseTOML(`
		[table-1]
		key1 = "some string"
		key2 = 123
		
		[table-2]
		key1 = "another string"
		key2 = 456
	`);
	assert(doc["table-1"].type == TOML_TYPE.TABLE);
	assert(doc["table-1"] == ["key1": TOMLValue("some string"), "key2": TOMLValue(123)]);
	assert(doc["table-2"] == ["key1": TOMLValue("another string"), "key2": TOMLValue(456)]);

	doc = parseTOML(`
		[dog."tater.man"]
		type = "pug"
	`);
	assert(doc["dog"]["tater.man"]["type"] == "pug");

	doc = parseTOML(`
		[a.b.c]            # this is best practice
		[ d.e.f ]          # same as [d.e.f]
		[ g .  h  . i ]    # same as [g.h.i]
		[ j . "ʞ" . 'l' ]  # same as [j."ʞ".'l']
	`);
	assert(doc["a"]["b"]["c"].type == TOML_TYPE.TABLE);
	assert(doc["d"]["e"]["f"].type == TOML_TYPE.TABLE);
	assert(doc["g"]["h"]["i"].type == TOML_TYPE.TABLE);
	assert(doc["j"]["ʞ"]["l"].type == TOML_TYPE.TABLE);

	doc = parseTOML(`
		# [x] you
		# [x.y] don't
		# [x.y.z] need these
		[x.y.z.w] # for this to work
	`);
	assert(doc["x"]["y"]["z"]["w"].type == TOML_TYPE.TABLE);

	doc = parseTOML(`
		[a.b]
		c = 1
		
		[a]
		d = 2
	`);
	assert(doc["a"]["b"]["c"] == 1);
	assert(doc["a"]["d"] == 2);

	/+testError({
			parseTOML(`
				# DO NOT DO THIS
					
				[a]
				b = 1
				
				[a]
				c = 2
			`);
		});

	testError({
			parseTOML(`
				# DO NOT DO THIS EITHER

				[a]
				b = 1

				[a.b]
				c = 2
			`);
		});+/

	testError({ parseTOML(`[]`); });
	testError({ parseTOML(`[a.]`); });
	testError({ parseTOML(`[a..b]`); });
	testError({ parseTOML(`[.b]`); });
	testError({ parseTOML(`[.]`); });

}

public TOMLDocument parseTOML(JSONValue json) {
	enforce!TOMLException(json.type == JSON_TYPE.OBJECT, "JSONValue is not an object");
	return TOMLDocument(parseObject(json));
}

private TOMLValue[string] parseObject(JSONValue json) {
	TOMLValue[string] ret;
	foreach(key, value; json.object) {
		ret[key] = parseImpl(value);
	}
	return ret;
}

private TOMLValue parseImpl(JSONValue json) {
	final switch(json.type) {
		case JSON_TYPE.NULL: return TOMLValue.init; // empty object (invalid)
		case JSON_TYPE.STRING: return TOMLValue(json.str);
		case JSON_TYPE.INTEGER: return TOMLValue(json.integer);
		case JSON_TYPE.UINTEGER: return TOMLValue(json.uinteger);
		case JSON_TYPE.FLOAT: return TOMLValue(json.floating);
		case JSON_TYPE.OBJECT: return TOMLValue(parseObject(json));
		case JSON_TYPE.ARRAY:
			TOMLValue[] ret;
			foreach(value ; json.array) {
				ret ~= parseImpl(value);
			}
			return TOMLValue(ret);
		case JSON_TYPE.TRUE: return TOMLValue(true);
		case JSON_TYPE.FALSE: return TOMLValue(false);
	}
}

class TOMLException : Exception {

	public this(string message, string file=__FILE__, size_t line=__LINE__) {
		super(message, file, line);
	}

}
